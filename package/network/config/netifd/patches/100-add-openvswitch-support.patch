Index: netifd-2019-08-05-5e02f944/CMakeLists.txt
===================================================================
--- netifd-2019-08-05-5e02f944.orig/CMakeLists.txt
+++ netifd-2019-08-05-5e02f944/CMakeLists.txt
@@ -26,6 +26,11 @@ SET(SOURCES
 SET(LIBS
 	ubox ubus uci json-c blobmsg_json)

+IF(NOT DEFINED LIBOVSDB_LIBS)
+  FIND_LIBRARY(libovsdb NAMES libovsdb ovsdb)
+#  SET(LIBOVSDB_LIBS ${libovsdb})
+ENDIF()
+
 IF (NOT DEFINED LIBNL_LIBS)
   FIND_LIBRARY(libnl NAMES libnl-3 libnl nl-3 nl)
   SET(LIBNL_LIBS ${libnl})
@@ -39,6 +44,10 @@ ELSE()
 	SET(SOURCES ${SOURCES} system-dummy.c)
 ENDIF()

+IF(NETIFD_OVS)
+  SET(SOURCES ${SOURCES} ovsbr.c system-ovs.c)
+ENDIF()
+
 IF(DEBUG)
   ADD_DEFINITIONS(-DDEBUG -g3)
   IF(NO_OPTIMIZE)
Index: netifd-2019-08-05-5e02f944/ovsbr.c
===================================================================
--- /dev/null
+++ netifd-2019-08-05-5e02f944/ovsbr.c
@@ -0,0 +1,756 @@
+/*
+ * netifd - network interface daemon
+ * Copyright (C) 2012 Felix Fietkau <nbd@openwrt.org>
+ * Copyright (C) 2020 Kevin Mahoney <kevin.mahoney@zenotec.net>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2
+ * as published by the Free Software Foundation
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#include <string.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <assert.h>
+#include <errno.h>
+
+#include "netifd.h"
+#include "device.h"
+#include "interface.h"
+#include "system.h"
+
+enum {
+	OVSBR_ATTR_IFNAME,
+	OVSBR_ATTR_STP,
+	OVSBR_ATTR_FORWARD_DELAY,
+	OVSBR_ATTR_PRIORITY,
+	OVSBR_ATTR_IGMP_SNOOP,
+	OVSBR_ATTR_AGEING_TIME,
+	OVSBR_ATTR_HELLO_TIME,
+	OVSBR_ATTR_MAX_AGE,
+	OVSBR_ATTR_BRIDGE_EMPTY,
+	OVSBR_ATTR_MULTICAST_QUERIER,
+	OVSBR_ATTR_HASH_MAX,
+	OVSBR_ATTR_ROBUSTNESS,
+	OVSBR_ATTR_QUERY_INTERVAL,
+	OVSBR_ATTR_QUERY_RESPONSE_INTERVAL,
+	OVSBR_ATTR_LAST_MEMBER_INTERVAL,
+	__OVSBR_ATTR_MAX
+};
+
+static const struct blobmsg_policy ovsbr_attrs[__OVSBR_ATTR_MAX] = {
+	[OVSBR_ATTR_IFNAME] = { "ifname", BLOBMSG_TYPE_ARRAY },
+	[OVSBR_ATTR_STP] = { "stp", BLOBMSG_TYPE_BOOL },
+	[OVSBR_ATTR_FORWARD_DELAY] = { "forward_delay", BLOBMSG_TYPE_INT32 },
+	[OVSBR_ATTR_PRIORITY] = { "priority", BLOBMSG_TYPE_INT32 },
+	[OVSBR_ATTR_AGEING_TIME] = { "ageing_time", BLOBMSG_TYPE_INT32 },
+	[OVSBR_ATTR_HELLO_TIME] = { "hello_time", BLOBMSG_TYPE_INT32 },
+	[OVSBR_ATTR_MAX_AGE] = { "max_age", BLOBMSG_TYPE_INT32 },
+	[OVSBR_ATTR_IGMP_SNOOP] = { "igmp_snooping", BLOBMSG_TYPE_BOOL },
+	[OVSBR_ATTR_BRIDGE_EMPTY] = { "bridge_empty", BLOBMSG_TYPE_BOOL },
+	[OVSBR_ATTR_MULTICAST_QUERIER] = { "multicast_querier", BLOBMSG_TYPE_BOOL },
+	[OVSBR_ATTR_HASH_MAX] = { "hash_max", BLOBMSG_TYPE_INT32 },
+	[OVSBR_ATTR_ROBUSTNESS] = { "robustness", BLOBMSG_TYPE_INT32 },
+	[OVSBR_ATTR_QUERY_INTERVAL] = { "query_interval", BLOBMSG_TYPE_INT32 },
+	[OVSBR_ATTR_QUERY_RESPONSE_INTERVAL] = { "query_response_interval", BLOBMSG_TYPE_INT32 },
+	[OVSBR_ATTR_LAST_MEMBER_INTERVAL] = { "last_member_interval", BLOBMSG_TYPE_INT32 },
+};
+
+static const struct uci_blob_param_info ovsbr_attr_info[__OVSBR_ATTR_MAX] = {
+	[OVSBR_ATTR_IFNAME] = { .type = BLOBMSG_TYPE_STRING },
+};
+
+static const struct uci_blob_param_list ovsbr_attr_list = {
+	.n_params = __OVSBR_ATTR_MAX,
+	.params = ovsbr_attrs,
+	.info = ovsbr_attr_info,
+
+	.n_next = 1,
+	.next = { &device_attr_list },
+};
+
+static struct device *ovsbr_create(const char *name, struct device_type *devtype,
+	struct blob_attr *attr);
+static void ovsbr_bridge_config_init(struct device *dev);
+static void ovsbr_free(struct device *dev);
+static void ovsbr_dump_info(struct device *dev, struct blob_buf *b);
+static enum dev_change_type ovsbr_reload(struct device *dev, struct blob_attr *attr);
+
+static struct device_type ovsbr_device_type = {
+	.name = "ovsbr",
+	.config_params = &ovsbr_attr_list,
+
+	.bridge_capability = true,
+	.name_prefix = "br",
+
+	.create = ovsbr_create,
+	.config_init = ovsbr_bridge_config_init,
+	.reload = ovsbr_reload,
+	.free = ovsbr_free,
+	.dump_info = ovsbr_dump_info,
+};
+
+struct ovsbr_state {
+	struct device dev;
+	device_state_cb set_state;
+
+	struct blob_attr *config_data;
+	struct bridge_config config;
+	struct blob_attr *ifnames;
+	bool active;
+	bool force_active;
+
+	struct uloop_timeout retry;
+	struct ovsbr_member *primary_port;
+	struct vlist_tree members;
+	int n_present;
+	int n_failed;
+};
+
+struct ovsbr_member {
+	struct vlist_node node;
+	struct ovsbr_state *bst;
+	struct device_user dev;
+	bool present;
+	char name[];
+};
+
+static void
+ovsbr_reset_primary(struct ovsbr_state *bst)
+{
+	struct ovsbr_member *bm;
+
+	if (!bst->primary_port &&
+	    (bst->dev.settings.flags & DEV_OPT_MACADDR))
+		return;
+
+	bst->primary_port = NULL;
+	bst->dev.settings.flags &= ~DEV_OPT_MACADDR;
+	vlist_for_each_element(&bst->members, bm, node) {
+		uint8_t *macaddr;
+
+		if (!bm->present)
+			continue;
+
+		bst->primary_port = bm;
+		if (bm->dev.dev->settings.flags & DEV_OPT_MACADDR)
+			macaddr = bm->dev.dev->settings.macaddr;
+		else
+			macaddr = bm->dev.dev->orig_settings.macaddr;
+		memcpy(bst->dev.settings.macaddr, macaddr, 6);
+		bst->dev.settings.flags |= DEV_OPT_MACADDR;
+		return;
+	}
+}
+
+static int
+ovsbr_disable_member(struct ovsbr_member *bm)
+{
+	struct ovsbr_state *bst = bm->bst;
+
+	if (!bm->present)
+		return 0;
+
+	system_ovsbr_delport(&bst->dev, bm->dev.dev);
+	device_release(&bm->dev);
+
+	device_broadcast_event(&bst->dev, DEV_EVENT_TOPO_CHANGE);
+
+	return 0;
+}
+
+static int
+ovsbr_enable_interface(struct ovsbr_state *bst)
+{
+	int ret;
+
+	if (bst->active)
+		return 0;
+
+	ret = system_ovsbr_addbr(&bst->dev, &bst->config);
+	if (ret < 0)
+		return ret;
+
+	bst->active = true;
+	return 0;
+}
+
+static void
+ovsbr_disable_interface(struct ovsbr_state *bst)
+{
+	if (!bst->active)
+		return;
+
+	system_ovsbr_delbr(&bst->dev);
+	bst->active = false;
+}
+
+static int
+ovsbr_enable_member(struct ovsbr_member *bm)
+{
+	struct ovsbr_state *bst = bm->bst;
+	int ret;
+
+	if (!bm->present)
+		return 0;
+
+	ret = ovsbr_enable_interface(bst);
+	if (ret)
+		goto error;
+
+	/* Disable IPv6 for bridge members */
+	if (!(bm->dev.dev->settings.flags & DEV_OPT_IPV6)) {
+		bm->dev.dev->settings.ipv6 = 0;
+		bm->dev.dev->settings.flags |= DEV_OPT_IPV6;
+	}
+
+	ret = device_claim(&bm->dev);
+	if (ret < 0)
+		goto error;
+
+	ret = system_ovsbr_addport(&bst->dev, bm->dev.dev);
+	if (ret < 0) {
+		D(DEVICE, "OVS Bridge device %s could not be added\n", bm->dev.dev->ifname);
+		goto error;
+	}
+
+	device_set_present(&bst->dev, true);
+	device_broadcast_event(&bst->dev, DEV_EVENT_TOPO_CHANGE);
+
+	return 0;
+
+error:
+	bst->n_failed++;
+	bm->present = false;
+	bst->n_present--;
+	device_release(&bm->dev);
+
+	return ret;
+}
+
+static void
+ovsbr_remove_member(struct ovsbr_member *bm)
+{
+	struct ovsbr_state *bst = bm->bst;
+
+	if (!bm->present)
+		return;
+
+	if (bst->dev.active)
+		ovsbr_disable_member(bm);
+
+	bm->present = false;
+	bm->bst->n_present--;
+
+	if (bm == bst->primary_port)
+		ovsbr_reset_primary(bst);
+
+	if (bst->config.bridge_empty)
+		return;
+
+	bst->force_active = false;
+	if (bst->n_present == 0)
+		device_set_present(&bst->dev, false);
+}
+
+static void
+ovsbr_free_member(struct ovsbr_member *bm)
+{
+	struct device *dev = bm->dev.dev;
+
+	ovsbr_remove_member(bm);
+	device_remove_user(&bm->dev);
+
+	/*
+	 * When reloading the config and moving a device from one bridge to
+	 * another, the other bridge may have tried to claim this device
+	 * before it was removed here.
+	 * Ensure that claiming the device is retried by toggling its present
+	 * state
+	 */
+	if (dev->present) {
+		device_set_present(dev, false);
+		device_set_present(dev, true);
+	}
+
+	free(bm);
+}
+
+static void
+ovsbr_check_retry(struct ovsbr_state *bst)
+{
+	if (!bst->n_failed)
+		return;
+
+	uloop_timeout_set(&bst->retry, 100);
+}
+
+static void
+ovsbr_member_cb(struct device_user *dev, enum device_event ev)
+{
+	struct ovsbr_member *bm = container_of(dev, struct ovsbr_member, dev);
+	struct ovsbr_state *bst = bm->bst;
+
+	switch (ev) {
+	case DEV_EVENT_ADD:
+		assert(!bm->present);
+
+		bm->present = true;
+		bst->n_present++;
+
+		if (bst->n_present == 1)
+			device_set_present(&bst->dev, true);
+		if (bst->dev.active && !ovsbr_enable_member(bm)) {
+			/*
+			 * Adding a bridge member can overwrite the bridge mtu
+			 * in the kernel, apply the bridge settings in case the
+			 * bridge mtu is set
+			 */
+			system_if_apply_settings(&bst->dev, &bst->dev.settings,
+						 DEV_OPT_MTU | DEV_OPT_MTU6);
+		}
+
+		break;
+	case DEV_EVENT_REMOVE:
+
+		if (dev->hotplug) {
+			vlist_delete(&bst->members, &bm->node);
+			return;
+		}
+
+		if (bm->present)
+			ovsbr_remove_member(bm);
+
+		break;
+	default:
+		return;
+	}
+}
+
+static int
+ovsbr_set_down(struct ovsbr_state *bst)
+{
+	struct ovsbr_member *bm;
+
+	bst->set_state(&bst->dev, false);
+
+	vlist_for_each_element(&bst->members, bm, node)
+		ovsbr_disable_member(bm);
+
+	ovsbr_disable_interface(bst);
+
+	return 0;
+}
+
+static int
+ovsbr_set_up(struct ovsbr_state *bst)
+{
+	struct ovsbr_member *bm;
+	int ret;
+
+	if (!bst->n_present) {
+		if (!bst->force_active)
+			return -ENOENT;
+
+		ret = ovsbr_enable_interface(bst);
+		if (ret)
+			return ret;
+	}
+
+	bst->n_failed = 0;
+	vlist_for_each_element(&bst->members, bm, node)
+		ovsbr_enable_member(bm);
+	ovsbr_check_retry(bst);
+
+	if (!bst->force_active && !bst->n_present) {
+		/* initialization of all member interfaces failed */
+		ovsbr_disable_interface(bst);
+		device_set_present(&bst->dev, false);
+		return -ENOENT;
+	}
+
+	ovsbr_reset_primary(bst);
+	ret = bst->set_state(&bst->dev, true);
+	if (ret < 0)
+		ovsbr_set_down(bst);
+
+	return ret;
+}
+
+static int
+ovsbr_set_state(struct device *dev, bool up)
+{
+	int ret = 0;
+	struct ovsbr_state *bst;
+
+	bst = container_of(dev, struct ovsbr_state, dev);
+
+	if (up)
+		ret = ovsbr_set_up(bst);
+	else
+		ret = ovsbr_set_down(bst);
+
+	return ret;
+}
+
+static struct ovsbr_member *
+ovsbr_create_member(struct ovsbr_state *bst, const char *name,
+		     struct device *dev, bool hotplug)
+{
+	struct ovsbr_member *bm;
+
+	bm = calloc(1, sizeof(*bm) + strlen(name) + 1);
+	if (!bm)
+		return NULL;
+
+	bm->bst = bst;
+	bm->dev.cb = ovsbr_member_cb;
+	bm->dev.hotplug = hotplug;
+	strcpy(bm->name, name);
+	bm->dev.dev = dev;
+	vlist_add(&bst->members, &bm->node, bm->name);
+
+	/*
+	 * Need to look up the bridge member again as the above
+	 * created pointer will be freed in case the bridge member
+	 * already existed
+	 */
+	bm = vlist_find(&bst->members, name, bm, node);
+	if (hotplug && bm)
+		bm->node.version = -1;
+
+	return bm;
+}
+
+static void
+ovsbr_member_update(struct vlist_tree *tree, struct vlist_node *node_new,
+		    struct vlist_node *node_old)
+{
+	struct ovsbr_member *bm;
+	struct device *dev;
+
+	if (node_new) {
+		bm = container_of(node_new, struct ovsbr_member, node);
+
+		if (node_old) {
+			free(bm);
+			return;
+		}
+
+		dev = bm->dev.dev;
+		bm->dev.dev = NULL;
+		device_add_user(&bm->dev, dev);
+	}
+
+	if (node_old) {
+		bm = container_of(node_old, struct ovsbr_member, node);
+		ovsbr_free_member(bm);
+	}
+}
+
+static void
+ovsbr_add_member(struct ovsbr_state *bst, const char *name)
+{
+	struct device *dev;
+
+	dev = device_get(name, true);
+	if (!dev)
+		return;
+
+	ovsbr_create_member(bst, name, dev, false);
+}
+
+static int
+ovsbr_hotplug_add(struct device *dev, struct device *member)
+{
+	struct ovsbr_state *bst = container_of(dev, struct ovsbr_state, dev);
+
+	ovsbr_create_member(bst, member->ifname, member, true);
+
+	return 0;
+}
+
+static int
+ovsbr_hotplug_del(struct device *dev, struct device *member)
+{
+	struct ovsbr_state *bst = container_of(dev, struct ovsbr_state, dev);
+	struct ovsbr_member *bm;
+
+	bm = vlist_find(&bst->members, member->ifname, bm, node);
+	if (!bm)
+		return UBUS_STATUS_NOT_FOUND;
+
+	vlist_delete(&bst->members, &bm->node);
+	return 0;
+}
+
+static int
+ovsbr_hotplug_prepare(struct device *dev)
+{
+	struct ovsbr_state *bst;
+
+	bst = container_of(dev, struct ovsbr_state, dev);
+
+	bst->force_active = true;
+	device_set_present(&bst->dev, true);
+
+	return 0;
+}
+
+static const struct device_hotplug_ops ovsbr_ops = {
+	.prepare = ovsbr_hotplug_prepare,
+	.add = ovsbr_hotplug_add,
+	.del = ovsbr_hotplug_del
+};
+
+static void
+ovsbr_free(struct device *dev)
+{
+	struct ovsbr_state *bst;
+
+	bst = container_of(dev, struct ovsbr_state, dev);
+	vlist_flush_all(&bst->members);
+	free(bst->config_data);
+	free(bst);
+}
+
+static void
+ovsbr_dump_info(struct device *dev, struct blob_buf *b)
+{
+	struct ovsbr_state *bst;
+	struct ovsbr_member *bm;
+	void *list;
+
+	bst = container_of(dev, struct ovsbr_state, dev);
+
+	system_if_dump_info(dev, b);
+	list = blobmsg_open_array(b, "bridge-members");
+
+	vlist_for_each_element(&bst->members, bm, node) {
+		if (bm->dev.dev->hidden)
+			continue;
+
+		blobmsg_add_string(b, NULL, bm->dev.dev->ifname);
+	}
+
+	blobmsg_close_array(b, list);
+}
+
+static void
+ovsbr_bridge_config_init(struct device *dev)
+{
+	struct ovsbr_state *bst;
+	struct blob_attr *cur;
+	int rem;
+
+	bst = container_of(dev, struct ovsbr_state, dev);
+
+	if (bst->config.bridge_empty) {
+		bst->force_active = true;
+		device_set_present(&bst->dev, true);
+	}
+
+	bst->n_failed = 0;
+	vlist_update(&bst->members);
+	if (bst->ifnames) {
+		blobmsg_for_each_attr(cur, bst->ifnames, rem) {
+			ovsbr_add_member(bst, blobmsg_data(cur));
+		}
+	}
+	vlist_flush(&bst->members);
+	ovsbr_check_retry(bst);
+
+}
+
+static void
+ovsbr_apply_settings(struct ovsbr_state *bst, struct blob_attr **tb)
+{
+	struct bridge_config *cfg = &bst->config;
+	struct blob_attr *cur;
+
+	/* defaults */
+	cfg->stp = false;
+	cfg->forward_delay = 2;
+	cfg->robustness = 2;
+	cfg->query_interval = 12500;
+	cfg->query_response_interval = 1000;
+	cfg->last_member_interval = 100;
+	cfg->hash_max = 512;
+	cfg->bridge_empty = false;
+	cfg->priority = 0x7FFF;
+
+	if ((cur = tb[OVSBR_ATTR_STP]))
+		cfg->stp = blobmsg_get_bool(cur);
+
+	if ((cur = tb[OVSBR_ATTR_FORWARD_DELAY]))
+		cfg->forward_delay = blobmsg_get_u32(cur);
+
+	if ((cur = tb[OVSBR_ATTR_PRIORITY]))
+		cfg->priority = blobmsg_get_u32(cur);
+
+	if ((cur = tb[OVSBR_ATTR_IGMP_SNOOP]))
+		cfg->multicast_querier = cfg->igmp_snoop = blobmsg_get_bool(cur);
+
+	if ((cur = tb[OVSBR_ATTR_MULTICAST_QUERIER]))
+		cfg->multicast_querier = blobmsg_get_bool(cur);
+
+	if ((cur = tb[OVSBR_ATTR_HASH_MAX]))
+		cfg->hash_max = blobmsg_get_u32(cur);
+
+	if ((cur = tb[OVSBR_ATTR_ROBUSTNESS])) {
+		cfg->robustness = blobmsg_get_u32(cur);
+		cfg->flags |= BRIDGE_OPT_ROBUSTNESS;
+	}
+
+	if ((cur = tb[OVSBR_ATTR_QUERY_INTERVAL])) {
+		cfg->query_interval = blobmsg_get_u32(cur);
+		cfg->flags |= BRIDGE_OPT_QUERY_INTERVAL;
+	}
+
+	if ((cur = tb[OVSBR_ATTR_QUERY_RESPONSE_INTERVAL])) {
+		cfg->query_response_interval = blobmsg_get_u32(cur);
+		cfg->flags |= BRIDGE_OPT_QUERY_RESPONSE_INTERVAL;
+	}
+
+	if ((cur = tb[OVSBR_ATTR_LAST_MEMBER_INTERVAL])) {
+		cfg->last_member_interval = blobmsg_get_u32(cur);
+		cfg->flags |= BRIDGE_OPT_LAST_MEMBER_INTERVAL;
+	}
+
+	if ((cur = tb[OVSBR_ATTR_AGEING_TIME])) {
+		cfg->ageing_time = blobmsg_get_u32(cur);
+		cfg->flags |= BRIDGE_OPT_AGEING_TIME;
+	}
+
+	if ((cur = tb[OVSBR_ATTR_HELLO_TIME])) {
+		cfg->hello_time = blobmsg_get_u32(cur);
+		cfg->flags |= BRIDGE_OPT_HELLO_TIME;
+	}
+
+	if ((cur = tb[OVSBR_ATTR_MAX_AGE])) {
+		cfg->max_age = blobmsg_get_u32(cur);
+		cfg->flags |= BRIDGE_OPT_MAX_AGE;
+	}
+
+	if ((cur = tb[OVSBR_ATTR_BRIDGE_EMPTY]))
+		cfg->bridge_empty = blobmsg_get_bool(cur);
+}
+
+static enum dev_change_type
+ovsbr_reload(struct device *dev, struct blob_attr *attr)
+{
+	struct blob_attr *tb_dev[__DEV_ATTR_MAX];
+	struct blob_attr *tb_br[__OVSBR_ATTR_MAX];
+	enum dev_change_type ret = DEV_CONFIG_APPLIED;
+	unsigned long diff;
+	struct ovsbr_state *bst;
+
+	BUILD_BUG_ON(sizeof(diff) < __OVSBR_ATTR_MAX / 8);
+	BUILD_BUG_ON(sizeof(diff) < __DEV_ATTR_MAX / 8);
+
+	bst = container_of(dev, struct ovsbr_state, dev);
+	attr = blob_memdup(attr);
+
+	blobmsg_parse(device_attr_list.params, __DEV_ATTR_MAX, tb_dev,
+		blob_data(attr), blob_len(attr));
+	blobmsg_parse(ovsbr_attrs, __OVSBR_ATTR_MAX, tb_br,
+		blob_data(attr), blob_len(attr));
+
+	if (tb_dev[DEV_ATTR_MACADDR])
+		bst->primary_port = NULL;
+
+	bst->ifnames = tb_br[OVSBR_ATTR_IFNAME];
+	device_init_settings(dev, tb_dev);
+	ovsbr_apply_settings(bst, tb_br);
+
+	if (bst->config_data) {
+		struct blob_attr *otb_dev[__DEV_ATTR_MAX];
+		struct blob_attr *otb_br[__OVSBR_ATTR_MAX];
+
+		blobmsg_parse(device_attr_list.params, __DEV_ATTR_MAX, otb_dev,
+			blob_data(bst->config_data), blob_len(bst->config_data));
+
+		diff = 0;
+		uci_blob_diff(tb_dev, otb_dev, &device_attr_list, &diff);
+		if (diff)
+		    ret = DEV_CONFIG_RESTART;
+
+		blobmsg_parse(ovsbr_attrs, __OVSBR_ATTR_MAX, otb_br,
+			blob_data(bst->config_data), blob_len(bst->config_data));
+
+		diff = 0;
+		uci_blob_diff(tb_br, otb_br, &ovsbr_attr_list, &diff);
+		if (diff & ~(1 << OVSBR_ATTR_IFNAME))
+		    ret = DEV_CONFIG_RESTART;
+
+		ovsbr_bridge_config_init(dev);
+	}
+
+	free(bst->config_data);
+	bst->config_data = attr;
+	return ret;
+}
+
+static void
+ovsbr_retry_members(struct uloop_timeout *timeout)
+{
+	struct ovsbr_state *bst = container_of(timeout, struct ovsbr_state, retry);
+	struct ovsbr_member *bm;
+
+	bst->n_failed = 0;
+	vlist_for_each_element(&bst->members, bm, node) {
+		if (bm->present)
+			continue;
+
+		if (!bm->dev.dev->present)
+			continue;
+
+		bm->present = true;
+		bst->n_present++;
+		ovsbr_enable_member(bm);
+	}
+}
+
+static struct device *
+ovsbr_create(const char *name, struct device_type *devtype,
+	struct blob_attr *attr)
+{
+	struct ovsbr_state *bst;
+	struct device *dev = NULL;
+
+	bst = calloc(1, sizeof(*bst));
+	if (!bst)
+		return NULL;
+
+	dev = &bst->dev;
+
+	if (device_init(dev, devtype, name) < 0) {
+		device_cleanup(dev);
+		free(bst);
+		return NULL;
+	}
+
+	dev->config_pending = true;
+	bst->retry.cb = ovsbr_retry_members;
+
+	bst->set_state = dev->set_state;
+	dev->set_state = ovsbr_set_state;
+
+	dev->hotplug_ops = &ovsbr_ops;
+
+	vlist_init(&bst->members, avl_strcmp, ovsbr_member_update);
+	bst->members.keep_old = true;
+	ovsbr_reload(dev, attr);
+
+	return dev;
+}
+
+static void __init ovsbr_device_type_init(void)
+{
+	device_type_add(&ovsbr_device_type);
+}
+
Index: netifd-2019-08-05-5e02f944/system-ovs.c
===================================================================
--- /dev/null
+++ netifd-2019-08-05-5e02f944/system-ovs.c
@@ -0,0 +1,167 @@
+/*
+ * netifd - network interface daemon
+ * Copyright (C) 2020 Kevin Mahoney <kevin.mahoney@zenotec.net>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2
+ * as published by the Free Software Foundation
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#include <stdlib.h>
+#include <stdio.h>
+#include <stdbool.h>
+#include <errno.h>
+#include <string.h>
+
+#include <fcntl.h>
+#include <unistd.h>
+
+#include <sys/types.h>
+#include <sys/wait.h>
+
+#include "netifd.h"
+#include "device.h"
+#include "interface.h"
+#include "system.h"
+
+static int
+forkexec(const char *file, const char **argv, void (*xfrm)(char *), char *buf, int len)
+{
+	char dbgbuf[512];
+	int status;
+	int io[2];
+	int pid;
+	int off;
+	int err;
+	char of;
+	char c;
+
+	if (!buf) {
+		buf = &c;
+		len = sizeof(c);
+	}
+
+	err = pipe(io);
+	if (err < 0)
+		return err;
+
+	buf[0] = 0;
+	len--; /* for NUL */
+
+	pid = fork();
+	switch (pid) {
+		case 0:
+			close(0);
+			close(1);
+			close(2);
+			dup2(io[1], 1);
+			close(io[0]);
+			close(io[1]);
+			execvp(file, (char **)argv);
+			exit(1);
+		case -1:
+			close(io[0]);
+			close(io[1]);
+			err = -1;
+			netifd_log_message(L_CRIT, "%s: %s: fork failed: %d (%s)\n",
+				 __func__, dbgbuf, errno, strerror(errno));
+			break;
+		default:
+			close(io[1]);
+			off = 0;
+			while (off < len) {
+				err = read(io[0], buf + off, len - off);
+				if (err <= 0)
+					break;
+				off += err;
+			}
+			while (read(io[0], &of, 1) == 1);
+			buf[off] = 0;
+			close(io[0]);
+			waitpid(pid, &status, 0);
+
+			err = 1;
+			if (WIFEXITED(status))
+				err = WEXITSTATUS(status);
+
+			if (xfrm)
+				xfrm(buf);
+
+			break;
+	}
+
+	return err;
+}
+
+static bool
+bridge_exists(struct device *bridge)
+{
+	char c;
+	const char *argv[] = { "ovs-vsctl", "br-exists", bridge->ifname, NULL };
+	return (forkexec(argv[0], argv, NULL, &c, sizeof(c)) == 0);
+}
+
+static bool
+port_exists(struct device *dev)
+{
+	char c;
+	const char *argv[] = { "ovs-vsctl", "port-to-br", dev->ifname, NULL };
+	return (forkexec(argv[0], argv, NULL, &c, sizeof(c)) == 0);
+}
+
+int system_ovsbr_addbr(struct device *bridge, struct bridge_config *cfg)
+{
+	char c;
+	int status = 0;
+	const char *argv[] = { "ovs-vsctl", "add-br", bridge->ifname, NULL };
+
+	if (! bridge_exists(bridge))
+		status = forkexec(argv[0], argv, NULL, &c, sizeof(c));
+
+	return (status == 0) ? 0 : -1;
+
+}
+
+int system_ovsbr_delbr(struct device *bridge)
+{
+	char c;
+	int status = 0;
+	const char *argv[] = { "ovs-vsctl", "del-br", bridge->ifname, NULL };
+
+	if (bridge_exists(bridge))
+		status = forkexec(argv[0], argv, NULL, &c, sizeof(c));
+
+	return (status == 0) ? 0 : -1;
+
+}
+
+int system_ovsbr_addport(struct device *bridge, struct device *dev)
+{
+	char c;
+	int status = 0;
+	const char *argv[] = { "ovs-vsctl", "add-port", bridge->ifname, dev->ifname, NULL };
+
+	if (! port_exists(dev))
+		status = forkexec(argv[0], argv, NULL, &c, sizeof(c));
+
+	return (status == 0) ? 0 : -1;
+
+}
+
+int system_ovsbr_delport(struct device *bridge, struct device *dev)
+{
+	char c;
+	int status = 0;
+	const char *argv[] = { "ovs-vsctl", "del-port", bridge->ifname, dev->ifname, NULL };
+
+	if (port_exists(dev))
+		status = forkexec(argv[0], argv, NULL, &c, sizeof(c));
+
+	return (status == 0) ? 0 : -1;
+
+}
+
Index: netifd-2019-08-05-5e02f944/system.h
===================================================================
--- netifd-2019-08-05-5e02f944.orig/system.h
+++ netifd-2019-08-05-5e02f944/system.h
@@ -186,6 +186,11 @@ int system_bridge_delbr(struct device *b
 int system_bridge_addif(struct device *bridge, struct device *dev);
 int system_bridge_delif(struct device *bridge, struct device *dev);

+int system_ovsbr_addbr(struct device *bridge, struct bridge_config *cfg);
+int system_ovsbr_delbr(struct device *bridge);
+int system_ovsbr_addport(struct device *bridge, struct device *dev);
+int system_ovsbr_delport(struct device *bridge, struct device *dev);
+
 int system_macvlan_add(struct device *macvlan, struct device *dev, struct macvlan_config *cfg);
 int system_macvlan_del(struct device *macvlan);

Index: netifd-2019-08-05-5e02f944/wireless.c
===================================================================
--- netifd-2019-08-05-5e02f944.orig/wireless.c
+++ netifd-2019-08-05-5e02f944/wireless.c
@@ -94,6 +94,7 @@ vif_config_add_bridge(struct blob_buf *b
 		dev->hotplug_ops->prepare(dev);

 	blobmsg_add_string(buf, "bridge", dev->ifname);
+	blobmsg_add_string(buf, "bridge_type", dev->type->name);

 	if (dev->settings.flags & DEV_OPT_MULTICAST_TO_UNICAST)
 		blobmsg_add_u8(buf, "multicast_to_unicast",
Index: netifd-2019-08-05-5e02f944/scripts/netifd-wireless.sh
===================================================================
--- netifd-2019-08-05-5e02f944.orig/scripts/netifd-wireless.sh
+++ netifd-2019-08-05-5e02f944/scripts/netifd-wireless.sh
@@ -289,6 +289,7 @@ for_each_interface() {
 		json_select "$_w_iface"
 		if [ -n "$_w_types" ]; then
 			json_get_var network_bridge bridge
+			json_get_var network_bridge_type bridge_type
 			json_get_var multicast_to_unicast multicast_to_unicast
 			json_select config
 			_wireless_set_brsnoop_isolation "$multicast_to_unicast"
